
### `Sequential` 

Keras의 `Sequential` 모델은 딥러닝 모델을 구성하기 위한 가장 간단하고 일반적인 방법 중 하나입니다. 

모델은 여러 개의 층(layers)을 순차적으로 쌓아서 신경망을 구축하는 방식이다.

1. **순차적 구성:** 

- 층을 하나씩 순차적으로 쌓아가는 방식입니다. 이는 간단한 피드포워드(feedforward) 신경망에서 주로 사용됩니다. 각 층은 이전 층의 출력을 입력으로 받아들이게 됩니다.

2. **간단한 구조:** 

- `Sequential` 모델은 단순하게 층을 쌓는 용도로 사용되므로, 복잡한 네트워크 구조에는 부적합합니다. 복잡한 구조를 만들려면 함수형 API나 서브클래싱(Subclassing) API를 사용해야 합니다.

3. **쉬운 사용:** 

- 모델을 만들고 훈련하기 위한 구성이 간단하며, 코드를 짧고 명료하게 작성할 수 있습니다.

4. **높은 수준의 추상화:** 

- 사용자는 층을 추가하고 컴파일하여 모델을 사용할 수 있으며, 내부적인 디테일에 대한 걱정 없이 딥러닝 모델을 구축할 수 있습니다.

#### `Sequential` 모델 생성/구성

1. Keras 라이브러리를 불러옵니다: `from tensorflow.keras import Sequential`

2. Sequential 모델을 생성합니다: `model = Sequential()`

3. 모델에 층을 추가합니다: `model.add(...)`. 층을 여러 개 추가하여 모델을 구성합니다. 
   
   - 주로 `Dense` 층을 사용하며, 각 층의 매개변수를 지정합니다.

4. 모델을 컴파일합니다: `model.compile(...)`. 컴파일할 때 손실 함수, 옵티마이저 및 평가 메트릭을 설정합니다.

5. 모델을 훈련시킵니다: `model.fit(...)`. 학습 데이터를 사용하여 모델을 훈련시킵니다.

6. 모델을 평가하거나 예측에 사용합니다: `model.evaluate(...)` 또는 `model.predict(...)`.

간단한 딥러닝 모델을 구축하고 빠르게 실험해보고자 할 때, `Sequential` 모델은 매우 효과적이고 직관적인 방법입니다.

### `model.add()`

```py
# unit, input_shape 등을 설정해줘야 한다.
model.add(Dense(units=512, activation='relu', input_shape=(784,)))
```

- Sequential 모델에 층을 추가하는 메서드입니다.

- `Dense(units=512, activation='relu', input_shape=(784,))`: 이 부분은 추가되는 층의 구성을 정의합니다.

- **Dense**: Dense 층은 완전 연결 층을 의미합니다. 이 층은 이전 층과 현재 층의 모든 뉴런이 서로 연결된 층입니다.

- **units=512**: 이 층에 있는 `뉴런의 수`입니다. 512개의 뉴런이 이 층에 있음을 의미합니다. 이 숫자는 조절 가능하며, 모델의 복잡성을 조절하는데 중요한 역할을 합니다.

- **activation='relu'**: `활성화 함수를 지정`합니다. 이 층에서는 ReLU(Rectified Linear Unit) 활성화 함수를 사용합니다. ReLU는 `주로 은닉층`에서 사용되며, 입력이 양수인 경우에는 입력 값을 그대로 출력하고, 음수인 경우에는 0으로 출력하는 함수입니다.

- **input_shape=(784,)**: 이 층의 `입력 데이터의 형태`를 정의합니다. `784는 입력 데이터의 크기`를 나타내며, 이 예에서는 28x28 픽셀의 이미지 데이터를 일렬로 펼친 벡터로 입력받는다고 정의하고 있습니다.


### `Compile()`

```python
from tensorflow.keras.utils import to_categorical

# 예시 클래스 레이블
Y_train = [0, 1, 2, 0, 1]

# 클래스 레이블을 원핫인코딩
# 다중 클래스 분류(Multi-Class Classification) 문제에서 타겟 값을 원-핫 인코딩 형식으로 변환하기 위해 to_categorical 를 사용한다.
Y_train_encoded = to_categorical(Y_train, num_classes=3)

# 결과 출력
print(Y_train_encoded)
```

#### 주요 요소

1. **손실 함수 (Loss Function):** 

- 모델이 `예측한 결과와 실제 목표 값 사이의 차이를 측정하는 함수`입니다. 다양한 손실 함수 중에서 선택하게 됩니다. 선택한 문제 유형에 따라 다른 손실 함수를 사용합니다. 회귀 문제, 분류 문제, 시퀀스 생성 문제 등에 따라 다른 손실 함수를 선택합니다.

2. **옵티마이저 (Optimizer):** 

- 모델의 `가중치를 업데이트하는 방법을 결정하는 알고리즘`입니다. 경사 하강법의 변형 중 하나로, 학습 속도와 다양한 하이퍼파라미터에 영향을 미칩니다. Adam, RMSprop, SGD 등이 일반적으로 사용됩니다.

3. **평가 메트릭 (Metrics):** 
- 모델의 성능을 평가하는 데 사용되는 지표. 훈련 중 모델의 성능을 모니터링하고, 테스트 데이터에 대한 평가에 사용됩니다. 정확도, 손실 등이 일반적인 평가 메트릭이다.

**예제:**

```python
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Dense

# 모델 생성
model = Sequential()

# 모델에 층 추가
# unit, input_shape 등을 설정해줘야 한다.
model.add(Dense(units=512, activation='relu', input_shape=(784,)))
model.add(Dense(units=10, activation='softmax')

# 모델 컴파일
model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
```

위의 예제에서:

- `loss='categorical_crossentropy'`는 다중 클래스 분류 문제를 다루고 있음을 나타냅니다. 다른 문제 유형에 따라 손실 함수를 선택합니다.
- `optimizer='adam'`은 Adam 옵티마이저를 사용하여 모델 가중치를 업데이트합니다. 경사 하강법 옵티마이저 중 하나입니다.
- `metrics=['accuracy']`는 모델의 평가 메트릭으로 정확도를 사용한다는 것을 나타냅니다. 다른 평가 메트릭을 선택할 수 있습니다.

이렇게 모델을 컴파일하면 모델이 훈련할 준비가 된 상태가 됩니다. 학습 데이터에 모델을 훈련시키기 위해 `model.fit`을 사용할 수 있습니다.


### `model.fit()``

- Keras 모델을 학습시키기 위한 메서드

- `model.fit()` 메서드는 호출되면 모델은 학습 데이터에 대해 가중치를 조정, 지정된 에포크 횟수만큼 학습합니다. 학습 중에 손실 함수를 최소화하기 위해 최적화 알고리즘들을 사용하고, 검증 데이터를 기반으로 모델의 성능을 모니터링합니다. 

- 학습 중에 모델은 훈련 데이터에 대한 예측을 생성하고, 손실 함수를 통해 예측과 실제 타깃 간의 차이를 계산합니다. 이 차이를 최소화하면 모델이 데이터를 더 잘 예측하게 된다.

####  주요 매개변수

- `x`: `학습 데이터` (입력 데이터)입니다. `Numpy 배열 또는 배열의 리스트`로 제공됩니다. 각 배열은 하나의 데이터 포인트를 나타내며, 모든 데이터 포인트를 모아 배열의 리스트로 제공합니다.

- `y`: `타깃(목표)` 데이터입니다. 입력 데이터에 대한 실제 정답 레이블 또는 값입니다. `x`와 동일한 길이를 가져야 합니다.

- `epochs`: 모델이 학습 데이터를 `몇 번 반복`해서 학습할 것인지를 나타내는 정수 값입니다. 한 번의 에포크(epoch)는 `전체 학습 데이터 세트를 한 번 순회`하는 것을 의미합니다.

- `batch_size`: 가중치 업데이트와 `손실 계산에 사용되는 미니 배치의 크기`입니다. 즉, 전체 학습 데이터를 작은 미니 배치로 나누어 처리합니다.

- `validation_data`: 모델의 성능을 검증하기 위한 `검증 데이터`입니다. 이 데이터를 사용하여 에포크가 끝날 때마다 모델의 성능을 평가하고, 과적합을 감지하는 데 도움이 됩니다.
